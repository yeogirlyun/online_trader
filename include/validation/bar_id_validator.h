#pragma once

#include "common/types.h"
#include "strategy/signal_output.h"
#include "backend/backend_component.h"
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <stdexcept>

namespace sentio {

/**
 * @brief Validates one-to-one correspondence between signals and trades via bar_id
 * 
 * CRITICAL: Ensures that each signal maps to exactly one trade (or HOLD decision)
 * and that no trades are generated for non-existent signals or wrong bars.
 * 
 * This is a financial integrity check - any violation indicates a serious bug
 * that could lead to incorrect trading decisions and financial losses.
 */
class BarIdValidator {
public:
    struct ValidationResult {
        bool passed = true;
        std::vector<std::string> errors;
        std::vector<std::string> warnings;
        
        // Statistics
        size_t total_signals = 0;
        size_t total_trades = 0;
        size_t signals_with_trades = 0;
        size_t signals_with_hold = 0;
        size_t orphan_trades = 0;           // Trades without corresponding signal
        size_t duplicate_signal_ids = 0;    // Multiple signals with same bar_id
        size_t duplicate_trade_ids = 0;     // Multiple trades with same bar_id
        size_t missing_bar_ids = 0;         // Signals/trades with bar_id = 0
        
        std::string to_string() const;
    };
    
    /**
     * @brief Validate signal-to-trade correspondence
     * 
     * Checks:
     * 1. All signals have valid bar_id (non-zero)
     * 2. All trades have valid bar_id (non-zero)
     * 3. Each trade's bar_id matches exactly one signal's bar_id
     * 4. No orphan trades (trades without corresponding signal)
     * 5. No duplicate bar_ids in signals
     * 6. No duplicate bar_ids in trades
     * 7. Signal and trade timestamps match for same bar_id
     * 8. Signal and trade symbols match for same bar_id
     * 
     * @param signals Vector of signals generated by strategy
     * @param trades Vector of trades generated by backend
     * @param strict If true, treat warnings as errors
     * @return ValidationResult with detailed error/warning information
     */
    static ValidationResult validate(
        const std::vector<SignalOutput>& signals,
        const std::vector<BackendComponent::TradeOrder>& trades,
        bool strict = true
    );
    
    /**
     * @brief Validate signals from JSONL file
     * 
     * Reads signals from file and validates bar_id integrity
     */
    static ValidationResult validate_signal_file(
        const std::string& signal_file_path,
        bool strict = true
    );
    
    /**
     * @brief Validate trades from JSONL file
     * 
     * Reads trades from file and validates bar_id integrity
     */
    static ValidationResult validate_trade_file(
        const std::string& trade_file_path,
        bool strict = true
    );
    
    /**
     * @brief Validate signal-to-trade correspondence from files
     * 
     * Reads both signals and trades from JSONL files and validates correspondence
     */
    static ValidationResult validate_files(
        const std::string& signal_file_path,
        const std::string& trade_file_path,
        bool strict = true
    );
    
    /**
     * @brief Assert one-to-one correspondence (throws on failure)
     * 
     * This is the strictest validation - any violation throws an exception.
     * Use this in production code where financial integrity is critical.
     */
    static void assert_one_to_one(
        const std::vector<SignalOutput>& signals,
        const std::vector<BackendComponent::TradeOrder>& trades
    );
    
private:
    static std::vector<SignalOutput> load_signals_from_file(const std::string& path);
    static std::vector<BackendComponent::TradeOrder> load_trades_from_file(const std::string& path);
};

} // namespace sentio
